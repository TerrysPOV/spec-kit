use axum::{routing::post, Router, Json, response::IntoResponse};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use tracing::{info, error};
use std::process::Command;
use tempfile::NamedTempFile;
use std::fs;
use uuid::Uuid;

#[derive(Deserialize)]
struct RenderReq {
    cv_json: Value,
    #[serde(default)]
    cover_letter: Option<String>,
    #[serde(default)]
    company_brief: Option<String>,
}

#[derive(Serialize)]
struct RenderResp {
    pdf_url: String,
    pdf_size_bytes: u64,
    render_time_ms: u64,
}

async fn render(Json(req): Json<RenderReq>) -> impl IntoResponse {
    let start_time = std::time::Instant::now();

    // Generate unique PDF filename
    let pdf_id = Uuid::new_v4();
    let pdf_filename = format!("resume_{}.pdf", pdf_id);
    let pdf_path = format!("/tmp/{}", pdf_filename);

    // Create Typst template
    let typst_content = generate_typst_template(&req.cv_json, req.cover_letter.as_deref(), req.company_brief.as_deref());

    // Write Typst content to temporary file
    let typst_file = match create_temp_file(&typst_content, ".typ") {
        Ok(file) => file,
        Err(e) => {
            error!("Failed to create temp file: {}", e);
            return Json(serde_json::json!({
                "error": "Failed to create temporary file",
                "details": e.to_string()
            })).into_response();
        }
    };

    // Run Typst to generate PDF
    match generate_pdf(&typst_file.path().to_string_lossy(), &pdf_path) {
        Ok(pdf_size) => {
            let render_time = start_time.elapsed().as_millis() as u64;
            info!("PDF generated successfully: {} ({} bytes, {}ms)", pdf_filename, pdf_size, render_time);

            Json(RenderResp {
                pdf_url: format!("s3://bucket/{}", pdf_filename),
                pdf_size_bytes: pdf_size,
                render_time_ms: render_time,
            }).into_response()
        }
        Err(e) => {
            error!("PDF generation failed: {}", e);
            Json(serde_json::json!({
                "error": "PDF generation failed",
                "details": e.to_string()
            })).into_response()
        }
    }
}

fn generate_typst_template(cv_json: &Value, cover_letter: Option<&str>, company_brief: Option<&str>) -> String {
    let personal_info = &cv_json["personalInfo"];
    let experience = &cv_json["experience"];
    let skills = &cv_json["skills"];

    format!(
        r#"
// Resume Template - Generated by AI Resume Assistant
#set page(
  paper: "a4",
  margin: (x: 2cm, y: 2cm),
)

#set text(
  font: ("Linux Libertine", "Times New Roman"),
  size: 11pt,
  fill: rgb("#1a1a1a")
)

// Header with name and contact info
#align(center)[
  #text(size: 24pt, weight: "bold")[{}]
  #v(5pt)
  #text(size: 11pt, fill: rgb("#666666"))[
    {} • {} • {}
  ]
]

#v(15pt)

// Professional Summary
== Professional Summary
{}

#v(10pt)

// Experience
== Professional Experience
{}
#v(10pt)

// Skills
== Skills
#grid(
  columns: (1fr, 1fr, 1fr),
  gutter: 8pt,
  ..{}
    .map(skill => box(
      fill: rgb("#f0f8ff"),
      inset: 4pt,
      radius: 2pt,
      text(size: 9pt, fill: rgb("#1e40af"))[skill]
    ))
    .flatten()
)

{}

// Cover Letter (if provided)
{}
"#,
        personal_info["name"].as_str().unwrap_or("John Doe"),
        personal_info["email"].as_str().unwrap_or("john@example.com"),
        personal_info["phone"].as_str().unwrap_or("+1-555-0123"),
        personal_info["location"].as_str().unwrap_or("City, State"),
        cv_json["summary"].as_str().unwrap_or("Professional summary goes here."),

        // Experience section
        if let Some(exp_array) = experience.as_array() {
            exp_array.iter().map(|exp| {
                format!(
                    "*{}* at {} ({})\n{}",
                    exp["title"].as_str().unwrap_or("Position"),
                    exp["company"].as_str().unwrap_or("Company"),
                    exp["duration"].as_str().unwrap_or("Duration"),
                    exp["description"].as_str().unwrap_or("Description")
                )
            }).collect::<Vec<_>>().join("\n\n")
        } else {
            "Experience details go here.".to_string()
        },

        // Skills section
        if let Some(skills_array) = skills.as_array() {
            skills_array.iter().map(|skill| {
                skill.as_str().unwrap_or("Skill")
            }).collect::<Vec<_>>()
        } else {
            vec!["Skill 1", "Skill 2", "Skill 3"]
        },

        // Company brief section
        if let Some(brief) = company_brief {
            format!(
                "#v(15pt)\n== Company Intelligence\n{}",
                brief.replace('\n', "\n\n")
            )
        } else {
            String::new()
        },

        // Cover letter section
        if let Some(letter) = cover_letter {
            format!(
                "#pagebreak()\n== Cover Letter\n#v(20pt)\n{}",
                letter.replace('\n', "\n\n")
            )
        } else {
            String::new()
        }
    )
}

fn create_temp_file(content: &str, extension: &str) -> Result<NamedTempFile, Box<dyn std::error::Error>> {
    let mut file = NamedTempFile::with_suffix(extension)?;
    fs::write(file.path(), content)?;
    Ok(file)
}

fn generate_pdf(typst_file: &str, output_path: &str) -> Result<u64, Box<dyn std::error::Error>> {
    let output = Command::new("typst")
        .args(["compile", typst_file, output_path])
        .output()?;

    if output.status.success() {
        let metadata = fs::metadata(output_path)?;
        Ok(metadata.len())
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        Err(format!("Typst compilation failed: {}", stderr).into())
    }
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt().with_target(false).init();

    // Check if Typst is installed
    match Command::new("typst").arg("--version").output() {
        Ok(output) => {
            let version = String::from_utf8_lossy(&output.stdout);
            info!("Typst version: {}", version.trim());
        }
        Err(_) => {
            error!("Typst is not installed. Please install Typst to generate PDFs.");
            error!("Visit: https://typst.app/install");
            std::process::exit(1);
        }
    }

    let app = Router::new()
        .route("/render/resume", post(render))
        .route("/healthz", axum::routing::get(|| async { "ok" }));

    let addr = std::net::SocketAddr::from(([0,0,0,0], 8082));
    info!("render-svc listening on {}", addr);
    axum::serve(tokio::net::TcpListener::bind(addr).await.unwrap(), app).await.unwrap();
}
